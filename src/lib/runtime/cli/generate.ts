import * as fs from "node:fs";
import * as path from "node:path";
import { discoverModules, type DiscoveryResult } from "./discover";

export interface GenerateOptions {
  /** Source directory (default: ./src) */
  srcDir?: string;
  /** Output file path (default: ./src/index.ts) */
  outFile?: string;
  /** Default model to use */
  defaultModel?: string;
  /** Config file path to read additional options */
  configFile?: string;
}

interface HubConfig {
  defaultModel?: string;
  provider?: string;
}

/**
 * Read optional system.config.ts configuration
 */
function readConfig(configPath: string): HubConfig {
  if (!fs.existsSync(configPath)) return {};

  // For now, just parse the file for defaultModel
  // In a real implementation, we'd dynamically import it
  const content = fs.readFileSync(configPath, "utf-8");

  const config: HubConfig = {};

  // Simple regex to extract defaultModel
  const modelMatch = content.match(/defaultModel:\s*["']([^"']+)["']/);
  if (modelMatch) config.defaultModel = modelMatch[1];

  return config;
}

/**
 * Generate the index.ts file content
 */
function generateCode(
  discovery: DiscoveryResult,
  config: HubConfig,
  defaultModel: string
): string {
  const imports: string[] = [];
  const toolRegistrations: string[] = [];
  const pluginRegistrations: string[] = [];
  const agentRegistrations: string[] = [];

  // Import from agents/hub
  imports.push('import { AgentHub } from "agents/hub";');

  // Check if sandbox middleware might be used (from blueprint capabilities)
  const hasSandboxCapability = discovery.agents.some((a) =>
    a.blueprintCapabilities.includes("@sandbox")
  );
  if (hasSandboxCapability) {
    imports.push('import { Sandbox } from "@cloudflare/sandbox";');
  }
  imports.push("");

  // Process tools - filter to only include tool-like exports
  for (const mod of discovery.tools) {
    const importPath = `./${mod.relativePath.replace(/\.tsx?$/, "")}`;

    // Filter exports to those that look like tools (end with Tool or contain tool)
    const toolExports = mod.exports.filter(
      (exp) =>
        exp.toLowerCase().endsWith("tool") || exp.toLowerCase().includes("tool")
    );

    if (toolExports.length > 0) {
      const exportList = toolExports.join(", ");
      imports.push(`import { ${exportList} } from "${importPath}";`);

      for (const exp of toolExports) {
        // Infer tags from directory or use default
        const tags =
          mod.inferredTags.length > 0 ? mod.inferredTags : ["default"];
        toolRegistrations.push(`  .addTool(${exp}, ${JSON.stringify(tags)})`);
      }
    }
  }

  for (const mod of discovery.plugins) {
    const importPath = `./${mod.relativePath.replace(/\.tsx?$/, "")}`;

    if (mod.exports.length > 0) {
      const exportList = mod.exports.join(", ");
      imports.push(`import { ${exportList} } from "${importPath}";`);

      for (const exp of mod.exports) {
        const tags = mod.inferredTags.length > 0 ? mod.inferredTags : undefined;
        if (tags) {
          pluginRegistrations.push(
            `  .use(${exp}, ${JSON.stringify(tags)})`
          );
        } else {
          pluginRegistrations.push(`  .use(${exp})`);
        }
      }
    }
  }

  // Process agents (blueprints) - only default exports
  const blueprintVars: string[] = [];
  for (const mod of discovery.agents) {
    const importPath = `./${mod.relativePath.replace(/\.tsx?$/, "")}`;
    const baseName = path.basename(
      mod.relativePath,
      path.extname(mod.relativePath)
    );

    if (mod.hasDefault) {
      // Default export - the blueprint
      const varName = `${toPascalCase(baseName)}Blueprint`;
      imports.push(`import ${varName} from "${importPath}";`);
      blueprintVars.push(varName);
      agentRegistrations.push(`  .addAgent(${varName})`);
    }
  }

  // Build the output
  const model = config.defaultModel || defaultModel;

  const lines = [
    "// Auto-generated by `agents dev` - do not edit manually",
    "// Run `agents generate` to regenerate after changes to agents/, tools/, or plugins/",
    "",
    ...imports,
    "",
    `const hub = new AgentHub({ defaultModel: "${model}" })`,
    "  .defaults()",
    ...toolRegistrations,
    ...pluginRegistrations,
    ...agentRegistrations,
    ";",
    "",
    "const { HubAgent, Agency, handler } = hub.export();"
  ];

  // Export with Sandbox if needed
  if (hasSandboxCapability) {
    lines.push("export { HubAgent, Agency, Sandbox };");
  } else {
    lines.push("export { HubAgent, Agency };");
  }
  lines.push("export default handler;");
  lines.push("");

  return lines.join("\n");
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join("");
}

/**
 * Generate the wiring code for a convention-based agents project.
 */
export function generate(options: GenerateOptions = {}): string {
  const srcDir = path.resolve(options.srcDir || "./src");
  const outFile = path.resolve(options.outFile || "./src/index.ts");
  const configPath =
    options.configFile || path.join(srcDir, "system.config.ts");

  // Discover modules
  const discovery = discoverModules(srcDir);

  // Read config
  const config = readConfig(configPath);

  // Generate code
  const defaultModel = options.defaultModel || "gpt-4o";
  const code = generateCode(discovery, config, defaultModel);

  // Write output
  fs.mkdirSync(path.dirname(outFile), { recursive: true });
  fs.writeFileSync(outFile, code, "utf-8");

  console.log(`âœ“ Generated ${outFile}`);
  console.log(`  - ${discovery.agents.length} agent(s)`);
  console.log(`  - ${discovery.tools.length} tool module(s)`);
  console.log(`  - ${discovery.plugins.length} plugin module(s)`);

  return outFile;
}
